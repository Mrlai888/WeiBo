<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TypeScript | 技术文档</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="manifest" href="/WeiBo/photo.jpg">
    <link rel="apple-touch-icon" href="/WeiBo/photo.jpg">
    <meta name="description" content="我的个人网站">
    
    <link rel="preload" href="/WeiBo/assets/css/0.styles.408a9db9.css" as="style"><link rel="preload" href="/WeiBo/assets/js/app.de0b0b11.js" as="script"><link rel="preload" href="/WeiBo/assets/js/2.36bf89d1.js" as="script"><link rel="preload" href="/WeiBo/assets/js/22.51e83a58.js" as="script"><link rel="prefetch" href="/WeiBo/assets/js/10.e33a5240.js"><link rel="prefetch" href="/WeiBo/assets/js/11.0acf05f2.js"><link rel="prefetch" href="/WeiBo/assets/js/12.3f073600.js"><link rel="prefetch" href="/WeiBo/assets/js/13.def5cb41.js"><link rel="prefetch" href="/WeiBo/assets/js/14.67d442a3.js"><link rel="prefetch" href="/WeiBo/assets/js/15.6aa6a43b.js"><link rel="prefetch" href="/WeiBo/assets/js/16.0dbfc0a7.js"><link rel="prefetch" href="/WeiBo/assets/js/17.0bbf9d85.js"><link rel="prefetch" href="/WeiBo/assets/js/18.6c0115c7.js"><link rel="prefetch" href="/WeiBo/assets/js/19.8af7ae2f.js"><link rel="prefetch" href="/WeiBo/assets/js/20.6b8bc693.js"><link rel="prefetch" href="/WeiBo/assets/js/21.258cb1b2.js"><link rel="prefetch" href="/WeiBo/assets/js/23.098efe96.js"><link rel="prefetch" href="/WeiBo/assets/js/24.798d0f95.js"><link rel="prefetch" href="/WeiBo/assets/js/25.72d6a3ee.js"><link rel="prefetch" href="/WeiBo/assets/js/26.8d0786bf.js"><link rel="prefetch" href="/WeiBo/assets/js/27.1dacffe6.js"><link rel="prefetch" href="/WeiBo/assets/js/28.a1f2bc7b.js"><link rel="prefetch" href="/WeiBo/assets/js/29.c6239048.js"><link rel="prefetch" href="/WeiBo/assets/js/3.eb8d5ed9.js"><link rel="prefetch" href="/WeiBo/assets/js/30.8546514e.js"><link rel="prefetch" href="/WeiBo/assets/js/31.d392c00d.js"><link rel="prefetch" href="/WeiBo/assets/js/32.23b9c222.js"><link rel="prefetch" href="/WeiBo/assets/js/33.19b86591.js"><link rel="prefetch" href="/WeiBo/assets/js/4.7f0c1c53.js"><link rel="prefetch" href="/WeiBo/assets/js/5.607e5447.js"><link rel="prefetch" href="/WeiBo/assets/js/6.6bb92c25.js"><link rel="prefetch" href="/WeiBo/assets/js/7.4c3ce0c9.js"><link rel="prefetch" href="/WeiBo/assets/js/8.815f15a3.js"><link rel="prefetch" href="/WeiBo/assets/js/9.e0a3c4b2.js">
    <link rel="stylesheet" href="/WeiBo/assets/css/0.styles.408a9db9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/WeiBo/" class="home-link router-link-active"><!----> <span class="site-name">技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/WeiBo/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/WeiBo/me/" class="nav-link">
  个人中心
</a></div><div class="nav-item"><a href="/WeiBo/html/" class="nav-link">
  html/css
</a></div><div class="nav-item"><a href="/WeiBo/js/" class="nav-link">
  js
</a></div><div class="nav-item"><a href="/WeiBo/vue/" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/WeiBo/react/" class="nav-link">
  react
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="more" class="dropdown-title"><span class="title">more</span> <span class="arrow down"></span></button> <button type="button" aria-label="more" class="mobile-dropdown-title"><span class="title">more</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          拓展
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/WeiBo/more/Hybrid.html" class="nav-link">
  混合开发
</a></li><li class="dropdown-subitem"><a href="/WeiBo/more/login.html" class="nav-link">
  登录注册服务端
</a></li><li class="dropdown-subitem"><a href="/WeiBo/more/mysql.html" class="nav-link">
  Mysql
</a></li></ul></li><li class="dropdown-item"><h4>
          更多
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/WeiBo/more/yunServer.html" class="nav-link">
  云开发
</a></li><li class="dropdown-subitem"><a href="/WeiBo/more/ts.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  typeScript
</a></li><li class="dropdown-subitem"><a href="/WeiBo/more/webpack.html" class="nav-link">
  webpack
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://github.com/Mrlai888" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/WeiBo/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/WeiBo/me/" class="nav-link">
  个人中心
</a></div><div class="nav-item"><a href="/WeiBo/html/" class="nav-link">
  html/css
</a></div><div class="nav-item"><a href="/WeiBo/js/" class="nav-link">
  js
</a></div><div class="nav-item"><a href="/WeiBo/vue/" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/WeiBo/react/" class="nav-link">
  react
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="more" class="dropdown-title"><span class="title">more</span> <span class="arrow down"></span></button> <button type="button" aria-label="more" class="mobile-dropdown-title"><span class="title">more</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          拓展
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/WeiBo/more/Hybrid.html" class="nav-link">
  混合开发
</a></li><li class="dropdown-subitem"><a href="/WeiBo/more/login.html" class="nav-link">
  登录注册服务端
</a></li><li class="dropdown-subitem"><a href="/WeiBo/more/mysql.html" class="nav-link">
  Mysql
</a></li></ul></li><li class="dropdown-item"><h4>
          更多
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/WeiBo/more/yunServer.html" class="nav-link">
  云开发
</a></li><li class="dropdown-subitem"><a href="/WeiBo/more/ts.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  typeScript
</a></li><li class="dropdown-subitem"><a href="/WeiBo/more/webpack.html" class="nav-link">
  webpack
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://github.com/Mrlai888" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/WeiBo/more/" aria-current="page" class="sidebar-link">更多扩展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/#axios请求拦截器添加token" class="sidebar-link">axios请求拦截器添加token</a></li></ul></li><li><a href="/WeiBo/more/Hybrid.html" class="sidebar-link">混合开发（Hybrid）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/Hybrid.html#混合开发" class="sidebar-link">混合开发</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/Hybrid.html#原生调用js" class="sidebar-link">原生调用js</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/Hybrid.html#js调用原生" class="sidebar-link">js调用原生</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/Hybrid.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></li><li><a href="/WeiBo/more/login.html" class="sidebar-link">后端代码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/login.html#json文件实现后端服务" class="sidebar-link">json文件实现后端服务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/login.html#登录注册" class="sidebar-link">登录注册</a></li></ul></li><li class="sidebar-sub-header"><a href="/WeiBo/more/login.html#express实现后端服务" class="sidebar-link">express实现后端服务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/login.html#链接数据库" class="sidebar-link">链接数据库</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/login.html#实例化表" class="sidebar-link">实例化表</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/login.html#express实现登录注册" class="sidebar-link">express实现登录注册</a></li></ul></li></ul></li><li><a href="/WeiBo/more/yunServer.html" class="sidebar-link">云开发</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/yunServer.html#云数据库" class="sidebar-link">云数据库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/yunServer.html#连接云数据库" class="sidebar-link">连接云数据库</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/yunServer.html#数据库的增删查改" class="sidebar-link">数据库的增删查改</a></li></ul></li><li class="sidebar-sub-header"><a href="/WeiBo/more/yunServer.html#云存储" class="sidebar-link">云存储</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/yunServer.html#上传文件" class="sidebar-link">上传文件</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/yunServer.html#上传图片" class="sidebar-link" style="padding-left:3rem;">上传图片</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/yunServer.html#上传excel文件" class="sidebar-link" style="padding-left:3rem;">上传excel文件</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/yunServer.html#打开excel文档" class="sidebar-link" style="padding-left:3rem;">打开excel文档</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/yunServer.html#下载文件" class="sidebar-link">下载文件</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/yunServer.html#删除文件" class="sidebar-link">删除文件</a></li></ul></li><li class="sidebar-sub-header"><a href="/WeiBo/more/yunServer.html#云函数" class="sidebar-link">云函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/yunServer.html#云函数的调用" class="sidebar-link">云函数的调用</a></li></ul></li></ul></li><li><a href="/WeiBo/more/webpack.html" class="sidebar-link">webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#webpack" class="sidebar-link">webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#webpack-打包构建原理" class="sidebar-link">webpack 打包构建原理</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#webpack-核心" class="sidebar-link">webpack 核心</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#webpack-简易搭建流程" class="sidebar-link">webpack 简易搭建流程</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#运行-webpack-三种方法" class="sidebar-link">运行 webpack 三种方法</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#配置入口出口" class="sidebar-link">配置入口出口</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#常用插件" class="sidebar-link">常用插件</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#常用转换器" class="sidebar-link">常用转换器</a></li></ul></li><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#webpack-ts-react" class="sidebar-link">webpack+ts+react</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#脚手架生成" class="sidebar-link">脚手架生成</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#自主搭建" class="sidebar-link">自主搭建</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#新建webpack-config-js文件" class="sidebar-link" style="padding-left:3rem;">新建webpack.config.js文件</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#新建-babelrc-文件-配置如下" class="sidebar-link" style="padding-left:3rem;">新建.babelrc 文件，配置如下</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/webpack.html#在package-json文件里配置启动命令" class="sidebar-link" style="padding-left:3rem;">在package.json文件里配置启动命令：</a></li></ul></li></ul></li><li><a href="/WeiBo/more/ts.html" aria-current="page" class="active sidebar-link">TypeScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#一-ts的介绍安装与开发工具" class="sidebar-link">一. ts的介绍安装与开发工具</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_1-1-ts介绍" class="sidebar-link">1-1 ts介绍</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_2-2-ts的安装" class="sidebar-link">2-2  ts的安装</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_2-3-vscode-的配置" class="sidebar-link">2-3 vscode 的配置</a></li></ul></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#二-ts的数据类型" class="sidebar-link">二. ts的数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_2-1数据类型-基础" class="sidebar-link">2-1数据类型-基础：</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#布尔值" class="sidebar-link" style="padding-left:3rem;">布尔值</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#数字" class="sidebar-link" style="padding-left:3rem;">数字</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#字符串" class="sidebar-link" style="padding-left:3rem;">字符串</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#数组" class="sidebar-link" style="padding-left:3rem;">数组</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#元组" class="sidebar-link" style="padding-left:3rem;">元组</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#枚举" class="sidebar-link" style="padding-left:3rem;">枚举</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#any" class="sidebar-link" style="padding-left:3rem;">any</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#void" class="sidebar-link" style="padding-left:3rem;">void</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_2-2数据类型-高级" class="sidebar-link">2-2数据类型-高级</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#类型推断" class="sidebar-link" style="padding-left:3rem;">类型推断</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#什么是类型推断" class="sidebar-link" style="padding-left:3rem;">什么是类型推断</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#联合类型" class="sidebar-link" style="padding-left:3rem;">联合类型</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#访问联合类型的属性或方法" class="sidebar-link" style="padding-left:3rem;">访问联合类型的属性或方法</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#联合类型赋值的类型推断" class="sidebar-link" style="padding-left:3rem;">联合类型赋值的类型推断</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#null-和-undefined" class="sidebar-link" style="padding-left:3rem;">Null 和 Undefined</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#never" class="sidebar-link" style="padding-left:3rem;">Never</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#symbol" class="sidebar-link" style="padding-left:3rem;">Symbol</a></li></ul></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#三-ts中的函数详解" class="sidebar-link">三. ts中的函数详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_3-1-函数的类型" class="sidebar-link">3-1 函数的类型</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#函数声明" class="sidebar-link" style="padding-left:3rem;">函数声明</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#函数表达式" class="sidebar-link" style="padding-left:3rem;">函数表达式</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_3-2-用接口定义函数的形状" class="sidebar-link">3-2 用接口定义函数的形状</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_3-3-可选参数" class="sidebar-link">3-3 可选参数</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_3-4-参数默认值" class="sidebar-link">3-4 参数默认值</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_3-5-剩余参数" class="sidebar-link">3-5 剩余参数</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_3-6-重载" class="sidebar-link">3-6 重载</a></li></ul></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#四-接口" class="sidebar-link">四. 接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_4-1-接口定义" class="sidebar-link">4-1 接口定义</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#简单的例子-2" class="sidebar-link" style="padding-left:3rem;">简单的例子</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_4-2-可选属性" class="sidebar-link">4-2 可选属性</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_4-3-任意属性-索引签名" class="sidebar-link">4-3 任意属性（索引签名）</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_4-4-只读属性" class="sidebar-link">4-4 只读属性</a></li></ul></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#五-类" class="sidebar-link">五. 类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_5-1-类的概念" class="sidebar-link">5-1 类的概念</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_5-2-es6中类的用法" class="sidebar-link">5-2 ES6中类的用法</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#属性和方法" class="sidebar-link" style="padding-left:3rem;">属性和方法</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#类的继承" class="sidebar-link" style="padding-left:3rem;">类的继承</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#存取器" class="sidebar-link" style="padding-left:3rem;">存取器</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#静态方法" class="sidebar-link" style="padding-left:3rem;">静态方法</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_5-3-typescript中类的用法" class="sidebar-link">5-3 TypeScript中类的用法</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#public-private-和-protected" class="sidebar-link" style="padding-left:3rem;">public private 和 protected</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#readonly" class="sidebar-link" style="padding-left:3rem;">readonly</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#抽象类" class="sidebar-link" style="padding-left:3rem;">抽象类</a></li></ul></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#六-类和接口" class="sidebar-link">六. 类和接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_6-1-类实现接口" class="sidebar-link">6-1 类实现接口</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_6-2-接口继承接口" class="sidebar-link">6-2 接口继承接口</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_6-3-接口继承类" class="sidebar-link">6-3 接口继承类</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_6-4-混合类型" class="sidebar-link">6-4 混合类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#七-泛型" class="sidebar-link">七. 泛型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_7-1-简单的例子" class="sidebar-link">7-1 简单的例子</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_7-2-多个类型的参数" class="sidebar-link">7-2 多个类型的参数</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_7-3-泛型约束" class="sidebar-link">7-3 泛型约束</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_7-4-泛型接口" class="sidebar-link">7-4 泛型接口</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#_7-5-泛型类" class="sidebar-link">7-5 泛型类</a></li></ul></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#八-迭代器和生成器" class="sidebar-link">八. 迭代器和生成器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#可迭代性" class="sidebar-link">可迭代性</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#for-of-语句" class="sidebar-link">for..of 语句</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/ts.html#for-of-vs-for-in-语句" class="sidebar-link">for..of vs. for..in 语句</a></li></ul></li></ul></li><li><a href="/WeiBo/more/mysql.html" class="sidebar-link">Mysql</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/WeiBo/more/mysql.html#mysql-常用指令" class="sidebar-link">Mysql 常用指令</a></li><li class="sidebar-sub-header"><a href="/WeiBo/more/mysql.html#nodejs连接mysql" class="sidebar-link">nodejs连接mysql</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="typescript"><a href="#typescript" class="header-anchor">#</a> TypeScript</h1> <h2 id="一-ts的介绍安装与开发工具"><a href="#一-ts的介绍安装与开发工具" class="header-anchor">#</a> 一. ts的介绍安装与开发工具</h2> <h3 id="_1-1-ts介绍"><a href="#_1-1-ts介绍" class="header-anchor">#</a> 1-1 ts介绍</h3> <ul><li><p>TypeScript是由微软开发的一款开源的编程语言。</p></li> <li><p>TypeScript是Javascript的超集，遵循最新的ES6/ES5规范。TypeScript扩展了Javascript的语法。</p></li> <li><p>TypeScript更像后端Java、C#这样的面向对象的语言，可以让js开发大型项目。</p></li> <li><p>谷歌也在大力支持TypeScript的推广，谷歌的angular2.x+就是基于TS语法。</p></li> <li><p>TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上</p></li> <li><p>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。</p></li> <li><p>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。</p></li></ul> <h3 id="_2-2-ts的安装"><a href="#_2-2-ts的安装" class="header-anchor">#</a> 2-2  ts的安装</h3> <p>​</p> <div class="language- extra-class"><pre class="language-text"><code>cnpm  i  typescript -g

tsc  hello.ts

（tsc ./src/hello.ts --outFile ./dist/hello.js）
</code></pre></div><h3 id="_2-3-vscode-的配置"><a href="#_2-3-vscode-的配置" class="header-anchor">#</a> 2-3 vscode 的配置</h3> <p>​	1. tsc --init  生成tsconfig.json 配置文件，然后修改outDir:&quot;./dist&quot;</p> <p>​	2. 终端-运行任务-监视tsconfig.json</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;outDir&quot;: &quot;./dist&quot;,         
&quot;rootDir&quot;: &quot;./src&quot;,         
</code></pre></div><h2 id="二-ts的数据类型"><a href="#二-ts的数据类型" class="header-anchor">#</a> 二. ts的数据类型</h2> <p>​	typescript中为了使编写的代码更加规范，更有利于维护，增加了类型校验，在ts中主要给我们提供了如下数据类型：</p> <p>​</p> <div class="language- extra-class"><pre class="language-text"><code>布尔类型
数字类型
字符串类型
数组类型
元组类型
枚举类型
任意类型
null和undefined
void类型
never类型 (永远不会有返回值的情况，例如死循环、抛出异常的情况)
</code></pre></div><h3 id="_2-1数据类型-基础"><a href="#_2-1数据类型-基础" class="header-anchor">#</a> 2-1数据类型-基础：</h3> <p>​	TypeScript包含的最简单的数据单元有：数字，字符串，布尔值，Null 和 Undefined等。TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。常见的有布尔值、数字、字符串、数组、元组、枚举、any 和 void 等</p> <h4 id="布尔值"><a href="#布尔值" class="header-anchor">#</a> 布尔值</h4> <p>​	最基本的数据类型就是简单的<code>true/false</code>值，在JavaScript和TypeScript里叫做<code>boolean</code></p> <div class="language- extra-class"><pre class="language-text"><code>let isDone: boolean = false
</code></pre></div><h4 id="数字"><a href="#数字" class="header-anchor">#</a> 数字</h4> <p>​	和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是<code>number</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>let decLiteral: number = 6
</code></pre></div><h4 id="字符串"><a href="#字符串" class="header-anchor">#</a> 字符串</h4> <p>​	TypeScript像其它语言里一样，使用<code>string</code>表示文本数据类型。 和JavaScript一样，可以使用双引号（&quot;）或单引号（'）表示字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>let from: string = &quot;hello&quot;
from = &quot;world&quot;
</code></pre></div><p>​    也使用模版字符串，定义多行文本和内嵌表达式。 这种字符串是被反引号包围（`），并且以${ expr }这种形式嵌入表达式。</p> <div class="language- extra-class"><pre class="language-text"><code>let surname: string = `Felix`
let age: number = 37
let sentence: string = `Hello, my name is ${ surname }.

I'll be ${ age + 1 } years old next month.`
</code></pre></div><h4 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h4> <p>​	TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p> <div class="language- extra-class"><pre class="language-text"><code>let list: number[] = [1, 2, 3]
</code></pre></div><p>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p> <div class="language- extra-class"><pre class="language-text"><code>let list: Array&lt;number&gt; = [1, 2, 3]
</code></pre></div><h4 id="元组"><a href="#元组" class="header-anchor">#</a> 元组</h4> <p>​	元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。</p> <div class="language- extra-class"><pre class="language-text"><code>// 声明一个元组类型 x
let x: [string, number]
// 初始化 x
x = ['hello', 10] // OK
// 无效的初始值
x = [10, 'hello'] // Error
</code></pre></div><p>当访问一个已知索引的元素，会得到正确的类型：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(x[0].substr(1)) // OK
console.log(x[1].substr(1)) // Error, 'number' 不存在 'substr' 方法
</code></pre></div><p>当访问一个越界的元素，会出现错误：</p> <div class="language- extra-class"><pre class="language-text"><code>x[3] = &quot;world&quot; // Error, '[string, number]' 未定义第 3 个元素的类型.
console.log(x[5].toString()) // Error, '[string, number]' 未定义第 5 个元素的类型.
</code></pre></div><h4 id="枚举"><a href="#枚举" class="header-anchor">#</a> 枚举</h4> <p>​	enum类型是对JavaScript标准数据类型的一个补充。 使用枚举类型可以为一组数值赋予友好的名字。</p> <div class="language- extra-class"><pre class="language-text"><code>enum Color {Red, Green, Blue}
let c: Color = Color.Green
</code></pre></div><p>默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号：</p> <div class="language- extra-class"><pre class="language-text"><code>enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green
</code></pre></div><p>或者，全部都采用手动赋值：</p> <div class="language- extra-class"><pre class="language-text"><code>enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green
</code></pre></div><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p> <div class="language- extra-class"><pre class="language-text"><code>enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2]
console.log(colorName)  // 'Green'
</code></pre></div><h4 id="any"><a href="#any" class="header-anchor">#</a> any</h4> <p>​	有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用<code>any</code>类型来标记这些变量：</p> <div class="language- extra-class"><pre class="language-text"><code>let notSure: any = 4
notSure = &quot;maybe a string instead&quot; // OK 赋值了一个字符串
notSure = false // OK 赋值了一个布尔值
</code></pre></div><p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。</p> <div class="language- extra-class"><pre class="language-text"><code>let notSure: any = 4
notSure.ifItExists() // okay, ifItExists函数在运行时可能存在
notSure.toFixed() // okay, toFixed 函数存在 (在编译时不做检查)
</code></pre></div><p>当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p> <div class="language- extra-class"><pre class="language-text"><code>let list: any[] = [1, true, &quot;free&quot;]
list[1] = 100
</code></pre></div><h4 id="void"><a href="#void" class="header-anchor">#</a> void</h4> <p>​	某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>function echo(): void {
  console.log('做真实的自己，用良心做教育')
}
</code></pre></div><h3 id="_2-2数据类型-高级"><a href="#_2-2数据类型-高级" class="header-anchor">#</a> 2-2数据类型-高级</h3> <h4 id="类型推断"><a href="#类型推断" class="header-anchor">#</a> 类型推断</h4> <p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p> <h4 id="什么是类型推断"><a href="#什么是类型推断" class="header-anchor">#</a> 什么是类型推断</h4> <p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p> <div class="language- extra-class"><pre class="language-text"><code>let lunarDay = '初一'
lunarDay = 1
// Type '1' is not assignable to type 'string'.
</code></pre></div><p>事实上，它等价于：</p> <div class="language- extra-class"><pre class="language-text"><code>let lunarDay: string = '初一'
lunarDay = 1
</code></pre></div><p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：</p> <p>let myFavoriteNumber</p> <p>myFavoriteNumber = 'seven'</p> <p>myFavoriteNumber = 7</p> <p>let someValue: any = &quot;this is a string&quot;</p> <p>let strLength: number = (someValue).length</p> <p>另一个为as语法：</p> <p>let someValue: any = &quot;this is a string&quot;</p> <p>let strLength: number = (someValue as string).length</p> <p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好</p> <h4 id="联合类型"><a href="#联合类型" class="header-anchor">#</a> 联合类型</h4> <p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p> <h5 id="简单的例子"><a href="#简单的例子" class="header-anchor">#</a> 简单的例子</h5> <div class="language- extra-class"><pre class="language-text"><code>let lunarDay:string | number
lunarDay = '初一'
lunarDay = 1
</code></pre></div><p>联合类型使用 | 分隔每个类型。</p> <p>这里的<code>let lunarDay: string | number</code>的含义是，允许 lunarDay 的类型是 string 或者 number，但是不能是其他类型。</p> <h4 id="访问联合类型的属性或方法"><a href="#访问联合类型的属性或方法" class="header-anchor">#</a> 访问联合类型的属性或方法</h4> <p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p> <div class="language- extra-class"><pre class="language-text"><code>function getLength(something: string | number): number {
  return something.length
}
// Property 'length' does not exist on type 'string | number'.
// Property 'length' does not exist on type 'number'.
</code></pre></div><p>上例中，length 不是 string 和 number 的共有属性，所以会报错。 访问 string 和 number 的共有属性是没问题的：</p> <div class="language- extra-class"><pre class="language-text"><code>function getString(something: string | number): string {
  return something.toString()  //访问了number和string的公共属性toString,是没有任何问题的！
}
</code></pre></div><h4 id="联合类型赋值的类型推断"><a href="#联合类型赋值的类型推断" class="header-anchor">#</a> 联合类型赋值的类型推断</h4> <p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p> <div class="language- extra-class"><pre class="language-text"><code>let lunarDay: string | number
lunarDay = '初一'
console.log(lunarDay.length) // 2
lunarDay = 1
console.log(lunarDay.length) // 编译时报错
</code></pre></div><p>上例中，第二行的 lunarDay 被推断成了 string，访问它的 length 属性不会报错。 而第四行的 lunarDay 被推断成了 number，访问它的 length 属性时就报错了。</p> <h4 id="null-和-undefined"><a href="#null-和-undefined" class="header-anchor">#</a> Null 和 Undefined</h4> <p><code>null</code> 是一个只有一个值的特殊类型。表示一个空对象引用。用 typeof 检测 null 返回是 <code>object</code>。 typeof 一个没有值的变量会返回 <code>undefined</code>。</p> <p>null 和 Undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。</p> <p>在TypeScript中启用严格的空校验（--strictNullChecks）特性，使得 <code>null</code> 和 <code>undefined</code> 只能被赋值给 <code>void</code> 或本身对应的类型</p> <p>在 tsconfig.json 中启用 --strictNullChecks</p> <div class="language- extra-class"><pre class="language-text"><code>let x: number
x = 1 // 运行正确
x = undefined // 运行错误
x = null // 运行错误
</code></pre></div><p>在 tsconfig.json 中启用 --strictNullChecks，需要将x赋值为联合类型</p> <div class="language- extra-class"><pre class="language-text"><code>let x: number | null | undefined //本身对应的类型
x = 1 // 运行正确
x = undefined // 运行正确
x = null // 运行正确
</code></pre></div><h4 id="never"><a href="#never" class="header-anchor">#</a> Never</h4> <p>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。</p> <p>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</p> <p>下面是一些返回never类型的函数：</p> <div class="language- extra-class"><pre class="language-text"><code>// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
  throw new Error(message)
}

// 推断的返回值类型为never
function fail() {
  return error(&quot;Something failed&quot;)
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
  while (true) {
  }
}
</code></pre></div><h4 id="symbol"><a href="#symbol" class="header-anchor">#</a> Symbol</h4> <p>自ECMAScript 2015起，symbol成为了一种新的原生类型，就像number和string一样。 symbol类型的值是通过Symbol构造函数创建的。</p> <div class="language- extra-class"><pre class="language-text"><code>let sym1 = Symbol();
let sym2 = Symbol(&quot;key&quot;); // 可选的字符串key
</code></pre></div><p>Symbols是不可改变且唯一的。</p> <div class="language- extra-class"><pre class="language-text"><code>let sym2 = Symbol(&quot;key&quot;)
let sym3 = Symbol(&quot;key&quot;)

sym2 === sym3 // false, symbols是唯一的
</code></pre></div><p>像字符串一样，symbols也可以被用做对象属性的键。</p> <div class="language- extra-class"><pre class="language-text"><code>let sym = Symbol()

let obj = {
  [sym]: &quot;value&quot;
}

console.log(obj[sym]) // &quot;value&quot;
</code></pre></div><p>Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员。</p> <div class="language- extra-class"><pre class="language-text"><code>const getClassNameSymbol = Symbol()

class C {
  [getClassNameSymbol](){
    return &quot;C&quot;
  }
}

let c = new C()
let className = c[getClassNameSymbol]() 
console.log(className)// &quot;C&quot;
</code></pre></div><h2 id="三-ts中的函数详解"><a href="#三-ts中的函数详解" class="header-anchor">#</a> 三. ts中的函数详解</h2> <h3 id="_3-1-函数的类型"><a href="#_3-1-函数的类型" class="header-anchor">#</a> 3-1 函数的类型</h3> <h4 id="函数声明"><a href="#函数声明" class="header-anchor">#</a> 函数声明</h4> <p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：</p> <p>​</p> <div class="language- extra-class"><pre class="language-text"><code>// 函数声明（Function Declaration）
function sum(x, y) {
  return x + y
}

// 函数表达式（Function Expression）
let mySum = function (x, y) {
  return x + y
}
</code></pre></div><p>​</p> <p>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</p> <div class="language- extra-class"><pre class="language-text"><code>function sum(x: number, y: number): number {
  return x + y
}
</code></pre></div><p>注意，<strong>输入多余的（或者少于要求的）参数，是不被允许的</strong>：</p> <div class="language- extra-class"><pre class="language-text"><code>function sum(x: number, y: number): number {
  return x + y
}
sum(1, 2, 3)

// Expected 2 arguments, but got 3.
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>function sum(x: number, y: number): number {
  return x + y
}
sum(1)

// An argument for 'y' was not provided.
</code></pre></div><h4 id="函数表达式"><a href="#函数表达式" class="header-anchor">#</a> 函数表达式</h4> <p>如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：</p> <div class="language- extra-class"><pre class="language-text"><code>let mySum = function (x: number, y: number): number {
  return x + y
}
</code></pre></div><p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样：</p> <div class="language- extra-class"><pre class="language-text"><code>let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {
  return x + y
}
</code></pre></div><p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</p> <p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p> <p>在 ES6 中，<code>=&gt;</code> 叫做箭头函数，应用十分广泛，可以参考 <a href="https://www.cnblogs.com/mengff/p/9656486.html" target="_blank" rel="noopener noreferrer">ES6 中的箭头函数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h3 id="_3-2-用接口定义函数的形状"><a href="#_3-2-用接口定义函数的形状" class="header-anchor">#</a> 3-2 用接口定义函数的形状</h3> <p>我们也可以使用接口的方式来定义一个函数需要符合的形状：</p> <div class="language- extra-class"><pre class="language-text"><code>interface SearchFunc {
  (source: string, subString: string): boolean
}

let mySearch: SearchFunc
mySearch = function(source: string, subString: string) {
  return source.search(subString) !== -1
}
</code></pre></div><h3 id="_3-3-可选参数"><a href="#_3-3-可选参数" class="header-anchor">#</a> 3-3 可选参数</h3> <p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p> <p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p> <div class="language- extra-class"><pre class="language-text"><code>function buildName(firstName: string, lastName?: string) {
  if (lastName) {
  return firstName + ' ' + lastName
  } else {
  return firstName
  }
}
let tomcat = buildName('Tom', 'Cat')
let tom = buildName('Tom')
</code></pre></div><p>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong>：</p> <div class="language- extra-class"><pre class="language-text"><code>function buildName(firstName?: string, lastName: string) {
  if (firstName) {
  return firstName + ' ' + lastName
  } else {
  return lastName
  }
}
let tomcat = buildName('Tom', 'Cat')
let tom = buildName(undefined, 'Tom')

// A required parameter cannot follow an optional parameter.
</code></pre></div><h3 id="_3-4-参数默认值"><a href="#_3-4-参数默认值" class="header-anchor">#</a> 3-4 参数默认值</h3> <p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p> <div class="language- extra-class"><pre class="language-text"><code>function buildName(firstName: string, lastName: string = 'Cat') {
  return firstName + ' ' + lastName
}
let tomcat = buildName('Tom', 'Cat')
let tom = buildName('Tom')
</code></pre></div><p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p> <div class="language- extra-class"><pre class="language-text"><code>function buildName(firstName: string = 'Tom', lastName: string) {
  return firstName + ' ' + lastName
}
let tomcat = buildName('Tom', 'Cat')
let cat = buildName(undefined, 'Cat')
</code></pre></div><h3 id="_3-5-剩余参数"><a href="#_3-5-剩余参数" class="header-anchor">#</a> 3-5 剩余参数</h3> <p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）：</p> <div class="language- extra-class"><pre class="language-text"><code>function push(array, ...items) {
  items.forEach(function(item) {
  array.push(item)
  })
}

let a = []
push(a, 1, 2, 3)
</code></pre></div><p>事实上，<code>items</code> 是一个数组。所以我们可以用数组的类型来定义它：</p> <div class="language- extra-class"><pre class="language-text"><code>function push(array: any[], ...items: any[]) {
  items.forEach(function(item) {
  array.push(item)
  })
}

let a:any[] = []
push(a, 1, 2, 3)
</code></pre></div><h3 id="_3-6-重载"><a href="#_3-6-重载" class="header-anchor">#</a> 3-6 重载</h3> <p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p> <p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>'hello'</code> 的时候，输出反转的字符串 <code>'olleh'</code>。</p> <p>利用联合类型，我们可以这么实现：</p> <div class="language- extra-class"><pre class="language-text"><code>function reverse(x: number | string): number | string {
  if (typeof x === 'number') {
  return Number(x.toString().split('').reverse().join(''))
  } else if (typeof x === 'string') {
  return x.split('').reverse().join('')
  }
}
</code></pre></div><p>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</p> <p>这时，我们可以使用重载定义多个 <code>reverse</code> 的函数类型：</p> <div class="language- extra-class"><pre class="language-text"><code>function reverse(x: number): number
function reverse(x: string): string
function reverse(x: number | string): number | string {
  if (typeof x === 'number') {
  return Number(x.toString().split('').reverse().join(''))
  } else if (typeof x === 'string') {
  return x.split('').reverse().join('')
  }
}
</code></pre></div><p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。</p> <h2 id="四-接口"><a href="#四-接口" class="header-anchor">#</a> 四. 接口</h2> <h3 id="_4-1-接口定义"><a href="#_4-1-接口定义" class="header-anchor">#</a> 4-1 接口定义</h3> <p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p> <p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。 TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p> <h4 id="简单的例子-2"><a href="#简单的例子-2" class="header-anchor">#</a> 简单的例子</h4> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
  name: string
  age: number
}

let tom: Person = {
  name: 'Tom',
  age: 25
}
</code></pre></div><p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。 接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀。 定义的变量比接口少了一些属性是不允许的：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
  name: string
  age: number
}

let tom: Person = {
  name: 'Tom'
}
// Property 'age' is missing in type '{ name: string }' but required in type 'Person'.
</code></pre></div><p>多一些属性也是不允许的：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
  name: string
  age: number
}

let tom: Person = {
  name: 'Tom',
  age: 25,
  gender: 'male'
}

// Type '{ name: string age: number gender: string }' is not assignable to type 'Person'.
// Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.
</code></pre></div><p>可见， <em>赋值的时候，变量的形状必须和接口的形状保持一致。</em></p> <h3 id="_4-2-可选属性"><a href="#_4-2-可选属性" class="header-anchor">#</a> 4-2 可选属性</h3> <p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
  name: string
  age?: number
}

let tom: Person = {
  name: 'Tom'
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>interface Person {
  name: string
  age?: number
}

let tom: Person = {
  name: 'Tom',
  age: 25
}
</code></pre></div><p>可选属性的含义是该属性可以不存在。</p> <p>这时仍然不允许添加未定义的属性：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
  name: string
  age?: number
}

let tom: Person = {
  name: 'Tom',
  age: 25,
  gender: 'male'
}

// Type '{ name: string age: number gender: string }' is not assignable to type 'Person'.
// Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.
</code></pre></div><h3 id="_4-3-任意属性-索引签名"><a href="#_4-3-任意属性-索引签名" class="header-anchor">#</a> 4-3 任意属性（索引签名）</h3> <p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
  name: string
  age?: number
  [propName: string]: any
}

let tom: Person = {
  name: 'Tom',
  gender: 'male'
}
</code></pre></div><p>使用 [propName: string] 定义了任意属性取 string 类型的值。 需要注意的是，一旦定义了任意属性，<strong>那么确定属性和可选属性的类型都必须是它的类型的子集</strong>：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
  name: string
  age?: number
  [propName: string]: string
}

let tom: Person = {
  name: 'Tom',
  age: 25,
  gender: 'male'
}

// Property 'age' of type 'number | undefined' is not assignable to string index type 'string'.
// Type '{ name: string age: number gender: string }' is not assignable to type 'Person'.
// Property 'age' is incompatible with index signature.
// Type 'number' is not assignable to type 'string'.
</code></pre></div><p>上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。</p> <p>另外，在报错信息中可以看出，此时 <code>{ name: 'Tom', age: 25, gender: 'male' }</code> 的类型被推断成了 { <code>[x: string]: string | number name: string age: number gender: string }</code>，这是联合类型和接口的结合。</p> <h3 id="_4-4-只读属性"><a href="#_4-4-只读属性" class="header-anchor">#</a> 4-4 只读属性</h3> <p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
  readonly id: number
  name: string
  age?: number
  [propName: string]: any
}

let tom: Person = {
  id: 89757,
  name: 'Tom',
  gender: 'male'
}

tom.id = 9527
// Cannot assign to 'id' because it is a read-only property.
</code></pre></div><p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了。</p> <p>*<strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：*</strong></p> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
  readonly id: number
  name: string
  age?: number
  [propName: string]: any
}

let tom: Person = {
  name: 'Tom',
  gender: 'male'
}

tom.id = 89757
// Property 'id' is missing in type '{ name: string gender: string }' but required in type 'Person'.
// Cannot assign to 'id' because it is a read-only property.
</code></pre></div><p>上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。 第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了</p> <h2 id="五-类"><a href="#五-类" class="header-anchor">#</a> 五. 类</h2> <p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 <code>class</code>。</p> <p>TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p> <h3 id="_5-1-类的概念"><a href="#_5-1-类的概念" class="header-anchor">#</a> 5-1 类的概念</h3> <p>虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。</p> <ul><li>类(Class)：定义了一件事物的抽象特点，包含它的属性和方法</li> <li>对象（Object）：类的实例，通过 <code>new</code> 生成</li> <li>面向对象（OOP）的三大特性：封装、继承、多态</li> <li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li> <li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li> <li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 <code>Cat</code> 和 <code>Dog</code> 都继承自 <code>Animal</code>，但是分别实现了自己的 <code>eat</code> 方法。此时针对某一个实例，我们无需了解它是 <code>Cat</code> 还是 <code>Dog</code>，就可以直接调用 <code>eat</code> 方法，程序会自动判断出来应该如何执行 <code>eat</code></li> <li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li> <li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 <code>public</code> 表示公有属性或方法</li> <li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li> <li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li></ul> <h3 id="_5-2-es6中类的用法"><a href="#_5-2-es6中类的用法" class="header-anchor">#</a> 5-2 ES6中类的用法</h3> <p>下面我们先回顾一下 ES6 中类的用法。</p> <h4 id="属性和方法"><a href="#属性和方法" class="header-anchor">#</a> 属性和方法</h4> <p>使用 <code>class</code> 定义类，使用 <code>constructor</code> 定义构造函数。</p> <p>通过 <code>new</code> 生成新实例的时候，会自动调用构造函数。</p> <div class="language- extra-class"><pre class="language-text"><code>class Animal {
  constructor(public name) {
   this.name = name
  }
  sayHi() {
   return `My name is ${this.name}`
  }
}

let a = new Animal('Jack')
console.log(a.sayHi()) // My name is Jack
</code></pre></div><h4 id="类的继承"><a href="#类的继承" class="header-anchor">#</a> 类的继承</h4> <p>使用 <code>extends</code> 关键字实现继承，子类中使用 <code>super</code> 关键字来调用父类的构造函数和方法。</p> <div class="language- extra-class"><pre class="language-text"><code>class Cat extends Animal {
  constructor(name) {
  	super(name) // 调用父类的 constructor(name)
  }
  sayHi() {
  	return 'Meow, ' + super.sayHi() // 调用父类的 sayHi()
  }
}

let c = new Cat('Tom') // Tom
console.log(c.sayHi()) // Meow, My name is Tom
</code></pre></div><h4 id="存取器"><a href="#存取器" class="header-anchor">#</a> 存取器</h4> <p>使用 getter 和 setter 可以改变属性的赋值和读取行为：</p> <div class="language- extra-class"><pre class="language-text"><code>class Animal{
    constructor(public name:string){
        this.name = name
    }
    get sayHi(){
        return this.name
    }
    set sayHi(value:string){
        this.name = value
    }
}
let animal = new Animal(&quot;dog&quot;);
console.log(animal.sayHi)
animal.sayHi = &quot;pig&quot;
console.log(animal.sayHi)
</code></pre></div><h4 id="静态方法"><a href="#静态方法" class="header-anchor">#</a> 静态方法</h4> <p>使用 <code>static</code> 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用：</p> <div class="language- extra-class"><pre class="language-text"><code>class Animal {
  static isAnimal(a) {
  	return a instanceof Animal
  }
}

let a = new Animal('Jack')
Animal.isAnimal(a) // true
a.isAnimal(a) // TypeError: a.isAnimal is not a function
</code></pre></div><h3 id="_5-3-typescript中类的用法"><a href="#_5-3-typescript中类的用法" class="header-anchor">#</a> 5-3 TypeScript中类的用法</h3> <h4 id="public-private-和-protected"><a href="#public-private-和-protected" class="header-anchor">#</a> public private 和 protected</h4> <p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p> <ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code>的</li> <li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li> <li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li></ul> <p>下面举一些例子：</p> <div class="language- extra-class"><pre class="language-text"><code>class Animal{
    public name:string = &quot;cat&quot;
    public sayName(){
        console.log(&quot;sayName&quot;)
    }
}
let animal = new Animal()
console.log(animal.name)
animal.sayName()
</code></pre></div><p>上面的例子中，<code>name</code>与sayName 被设置为了 <code>public</code>，所以直接访问实例的属性和方法是允许的。</p> <p>如果属性不能被外部进行访问的话，请设置成private</p> <div class="language- extra-class"><pre class="language-text"><code>class Animal{
    private name:string = &quot;cat&quot;
    public sayName(){
        console.log(&quot;sayName&quot;)
    }
}
let animal = new Animal()
console.log(animal.name) //报错 name为私有属性，请在Animal类中进行访问
animal.sayName()
</code></pre></div><p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问</p> <div class="language- extra-class"><pre class="language-text"><code>class Animal{
    protected name:string = &quot;cat&quot;
    public sayName(){
        console.log(&quot;sayName&quot;)
    }
}
class Dog extends Animal{
    sayHi(){
        console.log(this.name) //子类可以访问父类的public与protected的属性和方法
    }
}
</code></pre></div><h4 id="readonly"><a href="#readonly" class="header-anchor">#</a> readonly</h4> <p>只读属性关键字，只允许出现在属性声明或索引签名中。</p> <div class="language- extra-class"><pre class="language-text"><code>class Animal{
    readonly name:string = &quot;cat&quot;
    public sayName(){
        console.log(&quot;sayName&quot;)
    }
}
let animal = new Animal()
animal.name = 'dog' //报错了 name只能读取不能进行修改
console.log(animal.name) 
</code></pre></div><h4 id="抽象类"><a href="#抽象类" class="header-anchor">#</a> 抽象类</h4> <p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p> <p>什么是抽象类？</p> <p>首先，抽象类是不允许被实例化的：</p> <div class="language- extra-class"><pre class="language-text"><code>abstract class Animal {
  public name:string = &quot;&quot;
  public constructor(name:string) {
  	this.name = name
  }
  public abstract sayHi():void
}

let a = new Animal('Jack')

// Cannot create an instance of an abstract class.
</code></pre></div><p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p> <p>其次，抽象类中的抽象方法必须被子类实现：</p> <div class="language- extra-class"><pre class="language-text"><code>abstract class Animal {
  public name:string = &quot;&quot;
  public constructor(name:string) {
  	this.name = name
  }
  public abstract sayHi():void
}

class Cat extends Animal {
  public sayHi() {
    console.log(`${this.name} is eating.`)
  }
}

let cat = new Cat('Tom')
cat.sayHi()
</code></pre></div><h2 id="六-类和接口"><a href="#六-类和接口" class="header-anchor">#</a> 六. 类和接口</h2> <p>之前学习过接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。</p> <p>这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。</p> <h3 id="_6-1-类实现接口"><a href="#_6-1-类实现接口" class="header-anchor">#</a> 6-1 类实现接口</h3> <p>实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p> <p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Alarm {
  alert():void
}

class Door {
}

class SecurityDoor extends Door implements Alarm {
  alert() {
  	console.log('SecurityDoor alert')
  }
}

class Car implements Alarm {
  alert() {
  	console.log('Car alert')
  }
}
</code></pre></div><p>一个类可以实现多个接口：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Alarm {
    alert():void
}
  
interface Light {
    lightOn():void
    lightOff():void
}
  
class Car implements Alarm, Light {
    alert() {
        console.log('Car alert')
    }
    lightOn() {
        console.log('Car light on')
    }
    lightOff() {
        console.log('Car light off')
    }
}
</code></pre></div><p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯。</p> <h3 id="_6-2-接口继承接口"><a href="#_6-2-接口继承接口" class="header-anchor">#</a> 6-2 接口继承接口</h3> <p>接口与接口之间可以是继承关系：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Alarm {
    alert():void
}
  
interface LightableAlarm extends Alarm {
    lightOn():void
    lightOff():void
}
</code></pre></div><p>上例中，我们使用 <code>extends</code> 使 <code>LightableAlarm</code> 继承 <code>Alarm</code>。</p> <h3 id="_6-3-接口继承类"><a href="#_6-3-接口继承类" class="header-anchor">#</a> 6-3 接口继承类</h3> <div class="language- extra-class"><pre class="language-text"><code>class Point {
    x: number = 1
    y: number = 2
}
  
interface Point3d extends Point {
   z:number
}
  
let point3d: Point3d  = {x:1,y:2,z:3}
</code></pre></div><h3 id="_6-4-混合类型"><a href="#_6-4-混合类型" class="header-anchor">#</a> 6-4 混合类型</h3> <p>之前学习过，可以使用接口的方式来定义一个函数需要符合的形状：</p> <div class="language- extra-class"><pre class="language-text"><code>interface SearchFunc {
  (source: string, subString: string): boolean
}

let mySearch: SearchFunc
mySearch = function(source: string, subString: string) {
  return source.search(subString) !== -1
}
</code></pre></div><h2 id="七-泛型"><a href="#七-泛型" class="header-anchor">#</a> 七. 泛型</h2> <p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p> <h3 id="_7-1-简单的例子"><a href="#_7-1-简单的例子" class="header-anchor">#</a> 7-1 简单的例子</h3> <p>首先，我们来实现一个函数 <code>createArray</code>，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：</p> <div class="language- extra-class"><pre class="language-text"><code>function createArray(length: number, value: any): Array&lt;any&gt; {
  let result = []
  for (let i = 0; i &lt; length; i++) {
    result[i] = value
  }
  return result
}

createArray(3, 'x'); // ['x', 'x', 'x']
</code></pre></div><p>上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。</p> <p>这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：</p> <p><code>Array</code> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 <code>value</code>的类型。</p> <p>这时候，泛型就派上用场了：</p> <div class="language- extra-class"><pre class="language-text"><code>function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {
  let result: T[] = []
  for (let i = 0; i &lt; length; i++) {
    result[i] = value
  }
  return result
}

createArray&lt;string&gt;(3, 'x'); // ['x', 'x', 'x']
</code></pre></div><p>上例中，我们在函数名后添加了<T>,其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array</code> 中即可使用了。</T></p> <p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来：</p> <div class="language- extra-class"><pre class="language-text"><code>function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {
    let result: T[] = []
    for (let i = 0; i &lt; length; i++) {
      result[i] = value
    }
    return result
  }
  
  createArray(3, 'x') // ['x', 'x', 'x']
</code></pre></div><h3 id="_7-2-多个类型的参数"><a href="#_7-2-多个类型的参数" class="header-anchor">#</a> 7-2 多个类型的参数</h3> <p>定义泛型的时候，可以一次定义多个类型参数：</p> <div class="language- extra-class"><pre class="language-text"><code>function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {
    return [tuple[1], tuple[0]]
}
console.log(swap([7, 'seven'])) // ['seven', 7]
</code></pre></div><p>上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的元组</p> <h3 id="_7-3-泛型约束"><a href="#_7-3-泛型约束" class="header-anchor">#</a> 7-3 泛型约束</h3> <p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：</p> <div class="language- extra-class"><pre class="language-text"><code>function loggingIdentity&lt;T&gt;(arg: T): T {
  console.log(arg.length)
  return arg
}

// Property 'length' does not exist on type 'T'.
</code></pre></div><p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p> <p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 <code>length</code> 属性的变量。这就是泛型约束：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Lengthwise {
    length: number
}

function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
    console.log(arg.length)
    return arg
}
</code></pre></div><p>上例中，我们使用了 <code>extends</code> 约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。</p> <p>此时如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code> 不包含 <code>length</code>，那么在编译阶段就会报错了：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Lengthwise {
  length: number
}

function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
  console.log(arg.length)
  return arg
}

loggingIdentity(7)

// Argument of type '7' is not assignable to parameter of type 'Lengthwise'.
</code></pre></div><h3 id="_7-4-泛型接口"><a href="#_7-4-泛型接口" class="header-anchor">#</a> 7-4 泛型接口</h3> <p>之前学习过接口中函数的定义，可以使用接口的方式来定义一个函数需要符合的形状：</p> <div class="language- extra-class"><pre class="language-text"><code>interface SearchFunc {
    (source: string, subString: string): boolean
}
  
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    return source.search(subString) !== -1
}
</code></pre></div><p>当然也可以使用含有泛型的接口来定义函数的形状：</p> <div class="language- extra-class"><pre class="language-text"><code>interface CreateArrayFunc {
    &lt;T&gt;(length: number, value: T): Array&lt;T&gt;
}
  
let createArray: CreateArrayFunc;
createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {
    let result: T[] = []
    for (let i = 0; i &lt; length; i++) {
        result[i] = value
    }
    return result
}

createArray(3, 'x') // ['x', 'x', 'x']
</code></pre></div><p>进一步，我们可以把泛型参数提前到接口名上：</p> <div class="language- extra-class"><pre class="language-text"><code>interface CreateArrayFunc&lt;T&gt; {
    (length: number, value: T): Array&lt;T&gt;
}
  
let createArray: CreateArrayFunc&lt;string&gt;
createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {
    let result: T[] = []
    for (let i = 0; i &lt; length; i++) {
        result[i] = value
    }
    return result
}

createArray(3, 'x'); // ['x', 'x', 'x']
</code></pre></div><p>注意，此时在使用泛型接口的时候，需要定义泛型的类型。</p> <h3 id="_7-5-泛型类"><a href="#_7-5-泛型类" class="header-anchor">#</a> 7-5 泛型类</h3> <p>与泛型接口类似，泛型也可以用于类的类型定义中：</p> <div class="language- extra-class"><pre class="language-text"><code>class GenericNumber&lt;T&gt; {
  zeroValue: T
  add: (x: T, y: T) =&gt; T
}

let myGenericNumber = new GenericNumber&lt;number&gt;()
myGenericNumber.zeroValue = 0
myGenericNumber.add = function(x, y) { return x + y }
</code></pre></div><p>此处 zeroValue，add 未赋值会出错，设置 &quot;strictPropertyInitialization&quot;: false, 关闭提示</p> <h2 id="八-迭代器和生成器"><a href="#八-迭代器和生成器" class="header-anchor">#</a> 八. 迭代器和生成器</h2> <h3 id="可迭代性"><a href="#可迭代性" class="header-anchor">#</a> 可迭代性</h3> <h3 id="for-of-语句"><a href="#for-of-语句" class="header-anchor">#</a> for..of 语句</h3> <p>for..of会遍历可迭代的对象，调用对象上的Symbol.iterator方法。 下面是在数组上使用 for..of的简单例子：</p> <div class="language- extra-class"><pre class="language-text"><code>let someArray = [1, &quot;string&quot;, false]

for (let entry of someArray) {
  console.log(entry) // 1, &quot;string&quot;, false
}
</code></pre></div><h3 id="for-of-vs-for-in-语句"><a href="#for-of-vs-for-in-语句" class="header-anchor">#</a> for..of vs. for..in 语句</h3> <p>for..of和for..in均可迭代一个列表；但是用于迭代的值却不同，for..in迭代的是对象的键的列表，而for..of则迭代对象的键对应的值。</p> <p>下面的例子展示了两者之间的区别：</p> <div class="language- extra-class"><pre class="language-text"><code>let list = [4, 5, 6]

for (let i in list) {
  console.log(i) // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;,
}

for (let i of list) {
  console.log(i) // &quot;4&quot;, &quot;5&quot;, &quot;6&quot;
}
</code></pre></div><p>另一个区别是for..in可以操作任何对象, 它提供了查看对象属性的一种方法。 但是 for..of关注于迭代对象的值。内置对象Map和Set已经实现了Symbol.iterator方法，让我们可以访问它们保存的值。</p> <div class="language- extra-class"><pre class="language-text"><code>let pets = new Set([&quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;]);
pets[&quot;species&quot;] = &quot;mammals&quot;

for (let pet in pets) {
  console.log(pet) // &quot;species&quot;
}

for (let pet of pets) {
  console.log(pet) // &quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;
}
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">6/12/2021, 6:20:36 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/WeiBo/more/webpack.html" class="prev">
        webpack
      </a></span> <span class="next"><a href="/WeiBo/more/mysql.html">
        Mysql
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/WeiBo/assets/js/app.de0b0b11.js" defer></script><script src="/WeiBo/assets/js/2.36bf89d1.js" defer></script><script src="/WeiBo/assets/js/22.51e83a58.js" defer></script>
  </body>
</html>
